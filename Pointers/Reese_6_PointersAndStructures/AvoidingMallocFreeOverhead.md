## Avoiding malloc/free Overhead
Когда структуры выделяются, а затем освобождаются повторно, будут возникать некоторые накладные расходы, что приведет к потенциально значительному снижению производительности. Один из подходов к решению этой проблемы - вести собственный список выделенных структур. Когда пользователю больше не нужен экземпляр структуры, он возвращается в пул. Когда требуется экземпляр, он получает объект из пула. Если в пуле нет доступных элементов, динамически выделяется новый экземпляр. Такой подход эффективно поддерживает пул структур, которые можно использовать и повторно использовать по мере необходимости.
Чтобы продемонстрировать этот подход, мы будем использовать ранее определенную структуру Person. Пул людей поддерживается в виде массива. Можно также использовать более сложный список, такой как связанный список, как показано в разделе «Односвязный список» на стр. 142. Чтобы упростить этот пример, используется массив указателей, как объявлено ниже: 
```c
#define LIST_SIZE 10
Person *list[LIST_SIZE];
```
Прежде чем список можно будет использовать, его необходимо инициализировать. Следующая функция присваивает `NULL`
```c
void initializeList() {
	for(int i=0; i<LIST_SIZE; i++) {
		list[i] = NULL;
	}
}
```
Две функции используются для добавления и извлечения людей. Первая - это функция getPerson, как показано ниже. Эта функция по возможности извлекает человека из списка. Элементы массива сравниваются с `NULL`. Возвращается первый ненулевой элемент, и его позиции в списке затем присваивается значение `NULL`. Если человека нет, то новый
создается и возвращается экземпляр Person. Это позволяет избежать необходимости динамического выделения памяти для человека каждый раз, когда требуется новая. Мы выделяем память только в том случае, если ее нет в пуле. Инициализация возвращенного экземпляра может быть выполнена либо до его возврата, либо вызывающей стороной, в зависимости от потребностей приложения: 
```c
Person *getPerson() {
	for(int i=0; i<LIST_SIZE; i++) {
		if(list[i] != NULL) {
			Person *ptr = list[i];
			list[i] = NULL;
			return ptr;
		}
	}
Person *person = (Person*)malloc(sizeof(Person));
return person;
}
```
Вторая функция - это `returnPerson`, которая либо добавляет человека в список, либо освобождает его. Элементы массива проверяются, чтобы увидеть, есть ли какие-либо значения `NULL`. Если это так, то в эту позицию добавляется человек и возвращается указатель. Если список заполнен, то указатели внутри `person` освобождаются с помощью функции `deallocatePerson`, person освобождается, а затем возвращается `NULL`: 
```c
Person *returnPerson(Person *person) {
	for(int i=0; i<LIST_SIZE; i++) {
		if(list[i] == NULL) {
			list[i] = person;
			return person;
		}
	}
	deallocatePerson(person);
	free(person);
	return NULL;
}
```
Следующее иллюстрирует инициализацию списка и добавление человека в cписок: 
```c
initializeList();
Person *ptrPerson;
ptrPerson = getPerson();
initializePerson(ptrPerson,"Ralph", "Fitsgerald","Mr.",35);
displayPerson(*ptrPerson);
returnPerson(ptrPerson);
```
Одна проблема, связанная с этим подходом, связана с размером списка. Если список слишком мал, потребуется много динамического выделения `malloc` и освобождения памяти `free`. Если список большой и структуры не используются, потенциально большой объем памяти может быть занят и недоступен для других целей. Более сложное управление организацией списка
можно использовать для управления размером списка.