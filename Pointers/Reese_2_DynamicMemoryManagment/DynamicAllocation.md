## Оглавление

[Функции динамического управления памятью](#Динамическая-память-выделяется-из-кучи (heap))

[Использование maloc](#Использование-`malloc`)

[To cast or not to cast (приведение типов)](#To-cast-or-not-to-cast-(приведение-типов))

[Ошибки выделения памяти](#Ошибки-выделения-памяти)
## Функции динамического управления памятью
#### Динамическая память выделяется из кучи (heap)
Для управления динамической памятью доступно несколько функций распределения памяти. 
Хотя то, что доступно, может зависеть от системы, 
в заголовочном файле `<stdlib.h>` 
в большинстве систем можно найти следующие функции:
```c
 void* malloc( size_t sizemem );

 void* realloc( void * ptrmem, size_t size );

 void* calloc( size_t number, size_t size );

 void  free( void * ptr_to_mem_block );
```
тип `size_t` объявлен в заголовочном файле `<stddef.h>`
```c
1. malloc -  выделяет size_t байт памяти из кучи
			 и возвращает нетипизированный указатель

2. realloc - перераспределяет память на больший
			 или меньший объем на основе ранее 
			 выделенного блока памяти

3. calloc -  выделяет и обнуляет память из кучи

4. free -    возвращает блок памяти в кучу
```


При последовательных вызовах выделения памяти нет никаких гарантий
относительно порядка памяти или непрерывности выделенной памяти. 
Однако выделенная память будет выровнена в соответствии с данными указателя.
Например, четырехбайтовое целое число 
будет размещено на границе адреса, делимого на четыре. 
Адрес, возвращаемый диспетчером кучи, будет содержать адрес младшего байта.
Например, функция malloc выделяет четыре байта по адресу 500, 
второе использование функции malloc выделяет память по адресу 600. 
Они оба находятся на границах четырехбайтовых адресов 
и не выделяют память из последовательных ячеек памяти. [К оглавлению ⬆️](#Оглавление)
### Использование `malloc`

```c
// выделение памяти под число

#include <stdio.h>
#include <stdlib.h>

int main()
{
	int *pi = (int*) malloc(sizeof(int));
	*pi = 5;
	printf("*pi: %d\n", *pi);
	free(pi);
	return 0;
}
```
```c
// выделение памяти под строку

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main()
{
	char *pch = (char*)malloc(strlen("Hello World!\n")+1);
	strcpy(pch,"Hello World!\n");
	printf("%s", pch);
	free(pch);
	return 0;
}
```
### To cast or not to cast (приведение типов)

До того, как указатель на `void*` был введен в `C`, требовалось явное приведение типов с `malloc`, чтобы остановить генерацию предупреждений, когда выполнялись назначения между несовместимыми типами указателей. Поскольку указатель на `void*` может быть назначен любому другому типу указателя, явное приведение типов больше не требуется. Некоторые разработчики считают явное приведение типов хорошей практикой, потому что:
- документируется назначение функции `malloc`
- делает код совместимым с `C ++` (или более ранним компилятором `C`), что требует явного приведения типов.

Использование приведения типа будет проблемой, если вы не включите файл заголовка для `malloc`. Компилятор может выдавать предупреждения. По умолчанию `C` предполагает, что функции возвращают целое число. Если вы не включите прототип для `malloc`, он будет предупреждать, когда вы попытаетесь присвоить целое число указателю.
[К оглавлению ⬆️](#Оглавление)
### Ошибки выделения памяти


Если вы объявляете указатель, но не можете выделить память по адресу, на который он указывает, перед его использованием, эта память обычно будет содержать мусор, что обычно приводит к недопустимой ссылке на память. Рассмотрим следующую кодовую последовательность:
```c
int *pi;
...
printf("%d\n",*pi);
```
При выполнении это может привести к исключению времени выполнения. Этот тип проблемы характерен для строк, как показано ниже:
```c
char *name;
printf("Enter a name: ");
scanf("%s",name);
```
Хотя может показаться, что это будет выполняться правильно, мы используем память, на которую ссылаются по имени. Однако эта память не была выделена. Эту проблему можно проиллюстрировать графически, заменив переменную `pi` на `name`
```
| pi | --> | ????????? | 
```
[К оглавлению ⬆️](#Оглавление)